"use strict";(self.webpackChunkKuiClientTemplate=self.webpackChunkKuiClientTemplate||[]).push([[205],{41458:(e,n,o)=>{o.r(n),o.d(n,{default:()=>t});const t="---\ntitle: Kubernetes -- Working with Jobs\nlayout:\n  1: left\n---\n\n# Kubernetes Jobs\n\nKubernetes supports parallel batch job scheduling via the **Job**\nresource type. A Job creates one or more Pods and ensures that a\nspecified number of them successfully terminate.\n\nIn this notebook, you will learn how to create a job to run multiple\ntasks in parallel and use Kui's **Sequence Diagram** to inspect jobs\nand pods.\n\n### Controlling Parallelism\n\nKubernetes Jobs use two parameters, `completions` and `parallelism`,\nto control how a Job is subdivided into units of work. Each unit of\nwork is executed by a **Pod**. In the example on the right, we\nspecified values of `20` and `4`, respectively. These parameters tell\nKubernetes to execute the Job across 20 Pods, but schedule at most 4\nPods to run concurrently.\n\nYou can see these values defined by expanding the `job.yaml` source.\n\nYou can also see the execution pattern visualized in the **Sequence\nDiagram** view. Note how there are steps of four Pods executed at a\ntime, with a new Pod being scheduled only when one of the prior Pods\nhas completed its work.\n\nThe gray hashed prefix of every bar represents the **cold start time**\nof the Pod. This is the time spent bringing up the Pod, and is in\ncontrast to the work you actually want to accomplish. If the cold\nstart penalty is high, you may want to consider coarsening your work:\ntry to do more work per Pod.\n\n---\n\n## Scheduling a Job\n\nFirst, let's create a namespace to keep our work isolated:\n\n```bash\nkubectl create ns kui-notebook-2\n```\n\nTo schedule a job, use `kubectl apply` with a definition of your\njob. The following command applies a `job.yaml` to our scratch\nnamespace. The response from this command is a live Sequence Diagram\nvisualization.\n\n```bash\nk apply -f plugins/plugin-kubectl/tests/data/k8s/job.yaml -n kui-notebook-2\n```\n\nThis visualization shows how the sub-tasks of our Job are scheduled,\nover time. You can see concurrency and cold start penalties. The live\ntable will update as tasks are scheduled and complete.\n\nYou may also switch to a list or grid view by clicking the toolbar\nbuttons at the bottom of the view.\n\n## Inspecting the details of Job execution\n\nTo view the details of the tasks, you may click on any of the rows of\nthe Sequence Diagram (or rows of the Table view; or cells of the Grid\nview). After Kubernetes runs the tasks in Pods, so, after clicking on\na task in the above view, the drilldown view you will see is a Pod\nview!\n\n```bash\nkubectl get Pod pi-f9qqg -o yaml -n kui-notebook-2\n```\n"}}]);